<html>
<head>
    <title>Poll Tool | Twitch API Example</title>
    <link rel="stylesheet" href="/twitch_misc/style.css" />
    <style>
        #left, #right {
            box-sizing: border-box;
            width: 49vw;
            display: inline-block;
            vertical-align: top;
        }
        input[type="text"], input[type="number"] {
            width: 100%;
        }
        input[type="button"], input[type="submit"] {
            width: 30%;
            background: green;
            cursor: pointer;
        }
        input[type="button"]:hover, input[type="submit"]:hover {
            background: red;
        }
    </style>
</head>
<body>
    <p>This example first uses <a href="https://dev.twitch.tv/docs/authentication/getting-tokens-oauth#oauth-implicit-code-flow" target="_blank">Implicit Auth</a> to get a token to use then will Various endpoints, with the "channel:manage:polls" scope</p>

    <p>Get the code for this example on <a href="https://github.com/BarryCarlyon/twitch_misc/tree/main/examples/poll_tool">Github</a> or just View the source instead</p>

    <a href="" id="authorize" target="barrysgithubtwitchauth">Authorize</a>
    <div id="status" class="show">Pending</div>

    <div id="left">
        <form action="" method="post" id="poll_form">
            <fieldset>
                <div>
                    <label for="poll_title">Title</label>
                    <input type="text" name="poll_title" id="poll_title" />
                    <p>Max 60 Characters</p>
                </div>
                <div>
                    <label for="poll_duration">Duration</label>
                    <input type="number" name="poll_duration" id="poll_duration" min="15" max="1800" step="1" value="60" />
                    <p>Between 15s and 1800s (30 minutes)</p>
                </div>
            </fieldset>
            <fieldset>
                <legend>Choices</legend>
                <div id="poll_choices">
                    <input type="text" name="poll_choice[]" />
                    <input type="text" name="poll_choice[]" />
                </div>
                <p>Max 25 Characters</p>
            </fieldset>
            <fieldset>
                <input type="button" id="add_choice" value="Add Choice (2-5)" />
                <input type="submit" value="Create Poll" />
                <input type="button" id="poll_end" value="Terminate Poll" />
            </fieldset>
        </form>
    </div>
    <div id="right"></div>


    <script type="text/javascript">
        // go populate this with a client_id
        var client_id = 'hozgh446gdilj5knsrsxxz8tahr3koz';
        var redirect = 'https://barrycarlyon.github.io/twitch_misc/';
        // setup a memory space for the token/userID
        var access_token = '';
        var user_id = '';
        var poll_id = '';

        let status = document.getElementById('status');

        // setuo authorise link
        document.getElementById('authorize').setAttribute('href', 'https://id.twitch.tv/oauth2/authorize?client_id=' + client_id + '&redirect_uri=' + encodeURIComponent(redirect) + '&response_type=token&scope=channel:manage:polls')

        async function processToken(token) {
            access_token = token;

            status.textContent = 'Got Token. Loading Things';

            // we need the userID
            let user_resp = await fetch(
                'https://api.twitch.tv/helix/users',
                {
                    method: 'GET',
                    headers: {
                        'Client-ID': client_id,
                        'Authorization': `Bearer ${access_token}`,
                        'Accept': 'application/json'
                    }
                }
            );

            console.log(user_resp);
            console.log(user_resp.headers('ratelimit-remaining'));

            if (user_resp.status != 200) {
                status.textContent = `Failed to obtain User information ${user_resp.status} - ${await user_resp.text()}`;
                return;
            }

            let user_data = await user_resp.json();
            if (user_data.data.length != 1) {
                status.textContent = `Failed to obtain a User`;
                return;
            }

            user_id = user_data.data[0].id;
            status.textContent = `Hello ${user_id} - ${user_data.data[0].login}`;
        }

        document.getElementById('add_choice').addEventListener('click', (e) => {
            let choices = document.getElementById('poll_choices').querySelectorAll('input');
            if (choices.length < 5) {
                // add one
                let copy = choices[choices.length - 1].cloneNode();
                copy.value = '';
                document.getElementById('poll_choices').append(copy);
            }
        });
        document.getElementById('poll_form').addEventListener('submit', (e) => {
            e.preventDefault();

            submitPoll();
        });
        document.getElementById('poll_end').addEventListener('click', endPoll);

        async function endPoll() {
            let poll_resp = await fetch(
                `https://api.twitch.tv/helix/polls`,
                {
                    method: 'PATCH',
                    headers: {
                        'Client-ID': client_id,
                        'Authorization': `Bearer ${access_token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        broadcaster_id: user_id,
                        id: poll_id,
                        status: 'TERMINATED'
                    })
                }
            );

            if (poll_resp.status == 200) {
                status.textContent = `TERMINATED a poll`;
            } else {
                status.textContent = `Failed to TERMINATED a poll ${poll_resp.status} - ${await poll_resp.text()}`;
            }
        }

        async function submitPoll() {
            let payload = {
                broadcaster_id: user_id,
                title: document.getElementById('poll_title').value,
                duration: parseInt(document.getElementById('poll_duration').value),
                choices: []
            }

            let choices = document.getElementById('poll_choices').querySelectorAll('input');
            choices.forEach(choice => {
                let text = choice.value.trim();

                if (text.length > 0) {
                    payload.choices.push({
                        title: text
                    });
                }
            });

            status.textContent = `Creating a poll`;

            let poll_resp = await fetch(
                'https://api.twitch.tv/helix/polls',
                {
                    method: 'POST',
                    headers: {
                        'Client-ID': client_id,
                        'Authorization': `Bearer ${access_token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(payload)
                }
            );

            if (poll_resp.status == 200) {
                status.textContent = `Created a poll`;

                let poll_data = await poll_resp.json();

                poll_id = poll_data.data[0].id;
                // init result timer checker
                drawResults();
            } else {
                status.textContent = `Failed to create a poll ${poll_resp.status} - ${await poll_resp.text()}`;
            }
        }

        async function drawResults() {
            status.textContent = 'Getting Poll';
            let poll_resp = await fetch(
                `https://api.twitch.tv/helix/polls?broadcaster_id=${user_id}&id=${poll_id}`,
                {
                    method: 'GET',
                    headers: {
                        'Client-ID': client_id,
                        'Authorization': `Bearer ${access_token}`,
                        'Accept': 'application/json'
                    }
                }
            );

            if (poll_resp.status != 200) {
                status.textContent = `Failed to get Poll Results ${poll_resp.status} - ${await poll_resp.text()}`;
                return
            }

            let poll_data = await poll_resp.json();
            if (poll_data.data.length != 1) {
                status.textContent = 'Failed to get poll data - not 1 record?';
                return;
            }

            let { title, choices, duration, started_at } = poll_data.data[0];

            let right = document.getElementById('right');
            right.textContent = '';

            let tit = document.createElement('h2');
            right.append(tit);
            tit.textContent = title;


            let total_votes = 0;
            let choi = document.createElement('div');
            right.append(choi);
            choices.forEach(choice => {
                total_votes += choice.votes;

                let dsp = document.createElement('div');
                choi.append(dsp);
                dsp.textContent = choice.title + ' - ' + choice.votes;
            });

            let tot = document.createElement('div');
            right.append(tot);
            tot.style.borderTop = '1px solid white';
            tot.textContent = total_votes + ' total';

            let lef = document.createElement('div');
            right.append(lef);
            lef.style.borderTop = '1px solid white';

            let ends = new Date(started_at);
            ends.setSeconds(ends.getSeconds() + duration);
            let diff = ends.getTime() - new Date().getTime();
            if (diff < 0) {
                diff = 0;
            }
            lef.textContent = Math.floor(diff / 1000) + 's';

            if (poll_data.data[0].status == 'ACTIVE') {
                setTimeout(drawResults, 1000);

                status.textContent = `Got Poll`;
            } else {
                status.textContent = `Poll is now ${poll_data.data[0].status}`;
            }
        }
    </script>
</body>
</html>

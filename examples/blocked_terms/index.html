<!doctype html>
<html lang="en">
<head>
    <title>Blocked Terms Manager | Twitch API Example</title>
    <link rel="stylesheet" href="/twitch_misc/style.css" />
    <script type="text/javascript" src="csvdrop.js"></script>

    <style>
        .modal_content {
            text-align: center;
            /*font-size: 50px;*/
        }
        .closer {
            position: absolute;
            top: 0px;
            left: 0px;
            background: rgb(169, 112, 255);
            padding: 4px;
        }
    </style>
</head>
<body>

    <a href="" id="authorize" target="barrysgithubtwitchauth">Authorize</a>
    <div id="statusresp">Awaiting Auth!</div>

    <form action="" method="post">
        <fieldset>
            <div>
                <label for="channel_id">Select Channel</label>
                <select id="channel_id" name="channel_id" disabled>
                    <option>Select Channel!</option>
                    <option value="self">My Own</option>
                </select>
                <input type="button" id="select_channel" value="Load Terms" disabled />
            </div>
        </fieldset>
        <fieldset>
            <div class="flex">
                <input type="button" id="csv_export" value="Export as CSV" disabled />
                <input type="button" id="csv_import" value="Import a CSV" disabled />
            </div>
        </fieldset>
        <table id="wordtable">
            <tbody></tbody>
            <tfoot>
                <tr>
                    <td></td>
                    <td colspan="2">
                        <input type="text" id="newterm" name="newterm" placeholder="New Word or Phrase" disabled />
                    </td>
                    <td>
                        <button id="newtermCreate" disabled>Create</button>
                    </td>
                </tr>
            </tfoot>
        </table>
    </form>

    <div>
        <p>The word or phrase to block from being used in the broadcaster's chat room. The term must contain a minimum of 2 characters and may contain up to a maximum of 500 characters.</p>
        <p>Terms may include a wildcard character (*). The wildcard character must appear at the beginning or end of a word or set of characters. For example, *foo or foo*.</p>
    </div>

    <script type="text/javascript">
        var client_id = 'hozgh446gdilj5knsrsxxz8tahr3koz';
        var redirect = 'https://barrycarlyon.github.io/twitch_misc/';
        // setup a memory space for the token
        var access_token = '';
        var user_id = '';
        var headers = {};
        var termsCSV = [];

        document.getElementById('authorize').setAttribute('href', `https://id.twitch.tv/oauth2/authorize?client_id=${client_id}&redirect_uri=${encodeURIComponent(redirect)}&response_type=token&scope=user:read:moderated_channels+moderator:manage:blocked_terms`)

        function processToken(token) {
            access_token = token;

            authorize.style.display = 'none';

            let els = document.querySelectorAll('[disabled]');
            els.forEach(el => {
                el.removeAttribute('disabled');
            });

            // we'll save some copy pasta by defining the headers
            headers = {
                'Client-ID': client_id,
                'Authorization': `Bearer ${access_token}`,
                'Accept': 'application/json'
            }

            getUser();
        }

        // first we need to get the userID that is using the tool
        // we'll user getUser (other options available)
        function getUser() {
            statusresp.textContent = 'Got Auth!';

            fetch(
                'https://api.twitch.tv/helix/users',
                {
                    method: 'GET',
                    headers
                }
            )
            .then(async resp => {
                if (resp.status != 200) {
                    console.error(resp.status, await resp.text());
                    throw new Error('User API returned a non 200');
                }
                return resp.json();
            })
            .then(resp => {
                let { data } = resp;
                if (data.length != 1) {
                    console.log(data);
                    statusresp.textContent = 'Did not get 1 user from the API';
                    return;
                }

                let { id, login } = data[0];
                statusresp.textContent = `Hello ${login}`;
                user_id = id;

                // and go
                getModeratedChannels();
            })
            .catch(err => {
                console.error(err);
                // gosh darn it
                statusresp.textContent = 'A bad error occured getting the user!';
            });

        }

        async function getModeratedChannels() {
            try {
                let channels = await pageTillDone(
                    'https://api.twitch.tv/helix/moderation/channels',
                    [
                        [ 'user_id', user_id ],
                        [ 'first', '100' ]
                    ]
                );

                for (var x=0;x<channels.length;x++) {
                    let { broadcaster_id, broadcaster_login } = channels[x];
                    let opt = document.createElement('option');
                    opt.value = broadcaster_id;
                    opt.textContent = broadcaster_login;
                    channel_id.append(opt);
                }
            } catch (e) {
                console.error(e);
            }
        }

        select_channel.addEventListener('click', (e) => {
            e.preventDefault();

            wordtable.querySelector('tbody').textContent = '';

            getBlockedTerms();
        });

        function channelID() {
            let broadcaster_id = channel_id.value;
            if (broadcaster_id == 'self') {
                broadcaster_id = user_id;
            }
            return broadcaster_id;
        }

        async function getBlockedTerms() {
            try {
                let terms = await pageTillDone(
                    'https://api.twitch.tv/helix/moderation/blocked_terms',
                    [
                        [ 'broadcaster_id', channelID() ],
                        [ 'moderator_id', user_id ],
                        [ 'first', '100' ]
                    ]
                );

                termsCSV = [
                    [ 'broadcaster_id', 'text', 'moderator_id', 'id', 'created_at', 'updated_at', 'expires_at' ]
                ];//reset memory
                for (var x=0;x<terms.length;x++) {
                    addTermRow(terms[x]);
                    termsCSV.push([
                        terms[x].broadcaster_id,
                        terms[x].text,
                        terms[x].moderator_id,
                        terms[x].id,
                        terms[x].created_at,
                        terms[x].updated_at,
                        terms[x].expires_at
                    ]);
                }
            } catch (e) {
                console.error(e);
            }
        }

        function addTermRow(term) {
            let already = document.getElementById(term.id);
            if (already) {
                return;
            }

            let row = wordtable.querySelector('tbody').insertRow();
            row.setAttribute('id', term.id);

            var td = row.insertCell();

            var btn = document.createElement('div');
            btn.setAttribute('data-wordID', term.id);
            btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash3" viewBox="0 0 16 16"><path d="M6.5 1h3a.5.5 0 0 1 .5.5v1H6v-1a.5.5 0 0 1 .5-.5M11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3A1.5 1.5 0 0 0 5 1.5v1H1.5a.5.5 0 0 0 0 1h.538l.853 10.66A2 2 0 0 0 4.885 16h6.23a2 2 0 0 0 1.994-1.84l.853-10.66h.538a.5.5 0 0 0 0-1zm1.958 1-.846 10.58a1 1 0 0 1-.997.92h-6.23a1 1 0 0 1-.997-.92L3.042 3.5zm-7.487 1a.5.5 0 0 1 .528.47l.5 8.5a.5.5 0 0 1-.998.06L5 5.03a.5.5 0 0 1 .47-.53Zm5.058 0a.5.5 0 0 1 .47.53l-.5 8.5a.5.5 0 1 1-.998-.06l.5-8.5a.5.5 0 0 1 .528-.47M8 4.5a.5.5 0 0 1 .5.5v8.5a.5.5 0 0 1-1 0V5a.5.5 0 0 1 .5-.5"/></svg>';
            btn.addEventListener('click', removeTerm);
            td.append(btn);

            var td = row.insertCell();
            td.textContent = term.id;
            var td = row.insertCell();
            td.textContent = term.text;
            var td = row.insertCell();
            td.textContent = term.created_at;
        }
        function removeTermRow(id) {
            let tblRow = document.getElementById(id);
            if (tblRow) {
                tblRow.remove();
            }
        }


        async function pageTillDone(u, p, after, passback) {
            if (!passback) {
                passback = [];
            }

            let url = new URL(u);
            let thisp = [ ...p ];
            if (after) {
                thisp.push([ 'after', after ]);
            }
            url.search = new URLSearchParams(thisp);

            // ug pagination...
            return fetch(
                url,
                {
                    method: 'GET',
                    headers
                }
            )
            .then(async resp => {
                if (resp.status != 200) {
                    console.error(resp.status, await resp.text());
                    throw new Error('API returned a non 200');
                }
                return resp.json();
            })
            .then(resp => {
                let { data, pagination } = resp;

                passback = [ ...passback, ...data ];

                if (pagination) {
                    let { cursor } = pagination;
                    if (cursor) {
                        console.log('loop', passback);
                        return pageTillDone(u, p, cursor, passback);
                    }
                }

                console.log('final return');
                return passback;
            })
            .catch(err => {
                console.error(err);
                // gosh darn it
                statusresp.textContent = 'A bad error occured!';

                throw err;
            });
        }

        async function removeTerm(e) {
            let id = e.currentTarget.getAttribute('data-wordID');
            console.log('nail', id);

            let req = await fetch(
                'https://api.twitch.tv/helix/moderation/blocked_terms',
                {
                    method: 'DELETE',
                    headers: {
                        ...headers,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        broadcaster_id: channelID(),
                        moderator_id: user_id,
                        id
                    })
                }
            );
            if (req.status == 204) {
                statusresp.textContent = 'Term Removed';
                removeTermRow(id);
            } else {
                statusresp.textContent = `Term failed removal with ${req.status}`;
                console.log(await req.text());
            }
        }

        async function createTerm(text) {
            let req = await fetch(
                'https://api.twitch.tv/helix/moderation/blocked_terms',
                {
                    method: 'POST',
                    headers: {
                        ...headers,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        broadcaster_id: channelID(),
                        moderator_id: user_id,
                        text
                    })
                }
            );

            let {data} = await req.json();

            if (req.status != 200) {
                statusresp.textContent = 'Failed to add Term';
                return;
            }
            if (data.length != 1) {
                statusresp.textContent = 'Term not cteated';
                return;
            }

            statusresp.textContent = `Term created with ID: ${data[0].id}`;
            // create row
            addTermRow(data[0]);
        }
        newtermCreate.addEventListener('click', (e) => {
            e.preventDefault();
            createTerm(newterm.value);
        });

        csv_export.addEventListener('click', (e) => {
            e.preventDefault();

            if (termsCSV.length <= 1) {
                return;
            }

            // Source: https://stackoverflow.com/questions/14964035/how-to-export-javascript-array-info-to-csv-on-client-side
            let csvContent = "data:text/csv;charset=utf-8," + termsCSV.map(e => e.join(",")).join("\n");
            var encodedUri = encodeURI(csvContent);
            window.open(encodedUri);

            /*
var encodedUri = encodeURI(csvContent);
var link = document.createElement("a");
link.setAttribute("href", encodedUri);
link.setAttribute("download", "my_data.csv");
document.body.appendChild(link); // Required for FF

link.click(); // This will download the data file named "my_data.csv".
            */
        });
        csv_import.addEventListener('click', (e) => {
            e.preventDefault();

            let popup = document.createElement('div');
            popup.classList.add('modal');
            let popin = document.createElement('div');
            popin.classList.add('modal_content');
            popup.append(popin);
            document.body.append(popup);

            popup.addEventListener('click', (e) => {
                if (e.target != e.currentTarget) {
                    return;
                }
                popup.remove();
            });

            var closer = document.createElement('div');
            closer.classList.add('closer');
            closer.addEventListener('click', (e) => {
                popup.remove();
            });
            closer.textContent = 'Close';
            popin.append(closer);

            var div = document.createElement('div');
            div.classList.add('draganddrop');
            div.textContent = 'Drag and Drop CSV file here';
            popin.append(div);

            bindImporter(popin);
        });

        function csvArrived(lines) {
            let mc = document.querySelector('.draganddrop');
            mc.textContent = 'Please select which column to use';

            let d = document.createElement('div');
            mc.append(d);
            d.classList.add('flex');

            let hasHeader = document.createElement('input');
            hasHeader.setAttribute('type', 'checkbox');
            hasHeader.setAttribute('name', 'hasHeader');
            hasHeader.setAttribute('id', 'hasHeader');
            hasHeader.setAttribute('checked', 'checked');
            d.append(hasHeader);

            let lbl = document.createElement('label');
            lbl.setAttribute('for', 'hasHeader');
            lbl.textContent = 'First row is header row';
            d.append(lbl);

            let go = document.createElement('button');
            go.textContent = 'Import';
            go.addEventListener('click', (e) => {
                e.preventDefault();

                let whichcol = document.querySelector('input[name="whichcol"]:checked').value;
                let hasHeader = document.querySelector('input[name="hasHeader"]').checked;
                let st = 0;
                if (hasHeader) {
                    st = 1;
                }

                console.log('Going', whichcol, hasHeader);

                // ok lets go
                for (var x=st;x<lines.length;x++) {
                    let word = lines[x][whichcol];
                    console.log('Create', word);
                    createTerm(word);
                }
            });
            d.append(go);

            let tbl = document.createElement('table');
            mc.append(tbl);

            let row = tbl.insertRow();
            for (var y=0;y<lines[0].length;y++) {
                let cell = row.insertCell();
                let sel = document.createElement('input');
                sel.setAttribute('type', 'radio');
                sel.setAttribute('name', 'whichcol');
                sel.value = y;
                cell.append(sel);
            }

            for (var x=0;x<lines.length;x++) {
                let row = tbl.insertRow();
                for (var y=0;y<lines[x].length;y++) {
                    let cell = row.insertCell();
                    cell.textContent = lines[x][y];
                }
            }
        }
    </script>
</body>
</html>
